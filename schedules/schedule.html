<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Groups - Project V RL</title>
  <link rel="stylesheet" href="../css/style.css" />
  <link rel="icon" type="image/png" href="../logos/favicon.png" />
</head>
<body>
  <!-- header injected by main.js -->

  <main class="content-grid single">
    <section class="card">
      <h2 style="text-align:center;margin-bottom:1rem;">Neo Egoist League — Group Stage</h2>

      <div class="groups-grid" id="groups-root">
        <p>Loading groups…</p>
      </div>

      <h2 style="text-align:center;margin:1.5rem 0 .75rem;">Neo Egoist League — Full Standings</h2>
      <div id="standings-root"><p>Loading standings…</p></div>

      <div id="upcoming" style="margin-top:1rem;"></div>
    </section>
  </main>

  <!-- footer injected by main.js -->
  <script src="../js/main.js" defer></script>
  <script>
    (function () {
      const GROUPS_URL  = '../data/groups.json';
      const MATCHES_URL = '../data/matches.json';

      const root = document.getElementById('groups-root');
      const upcomingDiv = document.getElementById('upcoming');

      const fetchJSON = (url) => fetch(url, { cache: 'no-store' }).then(r => r.json());

      function emptyStats(t) {
        return { id:t.id, name:t.name, logo:t.logo, color:t.color,
          pts:0, wins:0, losses:0, draws:0, games:0, gf:0, ga:0, gd:0 };
      }

      // --- UPDATED: count total games in the series (hs + as)
      function applyResult(map, homeId, awayId, hs, as) {
        const H = map.get(homeId), A = map.get(awayId);
        if (!H || !A) return; // id mismatch guard
        const seriesLen = (hs || 0) + (as || 0);

        H.games += seriesLen; A.games += seriesLen;
        H.gf += hs; H.ga += as; A.gf += as; A.ga += hs;
        H.gd = H.gf - H.ga; A.gd = A.gf - A.ga;

        if (hs > as) { H.wins++; H.pts += 3; A.losses++; }
        else if (hs < as) { A.wins++; A.pts += 3; H.losses++; }
        else { H.draws++; A.draws++; H.pts++; A.pts++; } // safety (shouldn't happen in BO5)
      }

      // --- UPDATED: add tiebreakers incl. losses (fewer better) and games (fewer better)
      function sortStandings(arr) {
        return arr.sort((a,b) =>
          b.pts - a.pts ||          // Points
          b.gd  - a.gd  ||          // Game diff
          b.wins - a.wins ||        // Wins
          a.losses - b.losses ||    // Fewer losses
          a.games  - b.games  ||    // Fewer games
          b.gf  - a.gf  ||          // Games For
          a.name.localeCompare(b.name)
        );
      }

      // === Full-standings helpers (BO5 rule) ===
      function pointsForBO5(gFor, gAgainst, didWin) {
        if (didWin) return 3;
        const hi = Math.max(gFor, gAgainst), lo = Math.min(gFor, gAgainst);
        return (hi === 3 && lo === 2) ? 1 : 0;
      }
      function applySeriesRow(row, gFor, gAgainst) {
        const win = gFor > gAgainst;
        row.games += (gFor + gAgainst);     // total games played
        row.gf += gFor; row.ga += gAgainst;
        row.gd = row.gf - row.ga;
        if (win) row.wins++; else row.losses++;
        row.pts += pointsForBO5(gFor, gAgainst, win);
      }

      // Render full standings using ALL scored matches (cross-group)
      function renderFullStandings(groups, matches) {
        const mount = document.getElementById('standings-root');
        if (!mount) return;

        // unique team list from groups.json
        const seen = new Set(), teams = [];
        groups.forEach(g => g.teams.forEach(t => { if (!seen.has(t.id)) { seen.add(t.id); teams.push(t); } }));
        const map = new Map(teams.map(t => [t.id, { id:t.id, name:t.name, logo:t.logo, color:t.color,
          pts:0, wins:0, losses:0, games:0, gf:0, ga:0, gd:0 }]));

        // count every finished series
        matches.forEach(m => {
          if (!Number.isFinite(m.homeScore) || !Number.isFinite(m.awayScore)) return;
          const H = map.get(m.home), A = map.get(m.away);
          if (!H || !A) return; // unknown slug guard
          applySeriesRow(H, m.homeScore, m.awayScore);
          applySeriesRow(A, m.awayScore, m.homeScore);
        });

        const rows = [...map.values()].sort((a,b) =>
          b.pts - a.pts ||
          b.gd  - a.gd  ||
          b.wins - a.wins ||
          a.losses - b.losses ||
          a.games  - b.games  ||
          b.gf  - a.gf  ||
          a.name.localeCompare(b.name)
        );

        // build table (reuses .group-table styles)
        mount.innerHTML = '';
        const table = document.createElement('table');
        table.className = 'group-table';
        table.innerHTML = `
          <thead>
            <tr>
              <th>Position</th><th>Team Crest</th><th>Team</th>
              <th>PTS</th><th>Wins</th><th>Losses</th><th>Games</th><th>G. Diff</th>
            </tr>
          </thead>
          <tbody></tbody>
        `;
        const tbody = table.querySelector('tbody');
        rows.forEach((t, i) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${i + 1}</td>
            <td><img src="../logos/${t.logo}" alt="${t.name} crest" width="28" height="28" loading="lazy" decoding="async"></td>
            <td style="${t.color ? `background:${t.color};` : ''}"><strong>${t.name}</strong></td>
            <td>${t.pts}</td><td>${t.wins}</td><td>${t.losses}</td><td>${t.games}</td><td>${t.gd}</td>
          `;
          tbody.appendChild(tr);
        });
        mount.appendChild(table);
      }

      function groupLetter(title) {
        const m = /Group\s+([A-D])/i.exec(title);
        return m ? m[1].toUpperCase() : null;
      }

      function render(groups, matches) {
        root.innerHTML = '';
        upcomingDiv.innerHTML = '';

        const byGroup = matches.reduce((m, x) => {
          (m[x.group] ||= []).push(x);
          return m;
        }, {});

        groups.forEach(g => {
          const map = new Map(g.teams.map(t => [t.id, emptyStats(t)]));
          const key = groupLetter(g.title);
          (byGroup[key] || []).forEach(m => {
            if (Number.isFinite(m.homeScore) && Number.isFinite(m.awayScore)) {
              applyResult(map, m.home, m.away, m.homeScore, m.awayScore);
            }
          });

          const tableData = sortStandings([...map.values()]);

          // Build card
          const card = document.createElement('div');
          card.className = 'group-card';
          card.style.setProperty('--accent', g.color || 'var(--brand)');

          const title = document.createElement('div');
          title.className = 'group-title';
          title.textContent = g.title;
          card.appendChild(title);

          const table = document.createElement('table');
          table.className = 'group-table';
          table.innerHTML = `
            <thead>
              <tr>
                <th>Position</th><th>Team Crest</th><th>Team</th>
                <th>PTS</th><th>Wins</th><th>Losses</th><th>Games</th><th>G. Diff</th>
              </tr>
            </thead>
            <tbody></tbody>
          `;
          const tbody = table.querySelector('tbody');

          tableData.forEach((t, idx) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${idx + 1}</td>
              <td><img src="../logos/${t.logo}" alt="${t.name} crest" width="28" height="28" loading="lazy" decoding="async"></td>
              <td style="${t.color ? `background:${t.color};` : ''}"><strong>${t.name}</strong></td>
              <td>${t.pts}</td><td>${t.wins}</td><td>${t.losses}</td><td>${t.games}</td><td>${t.gd}</td>
            `;
            tbody.appendChild(tr);
          });

          card.appendChild(table);
          root.appendChild(card);
        });

        // Upcoming list (unchanged)
        const upcoming = matches.filter(m => m.homeScore == null || m.awayScore == null);
        if (upcoming.length) {
          const ul = document.createElement('ul');
          ul.style.listStyle = 'none';
          ul.style.paddingLeft = '0';
          ul.innerHTML = `<h3 style="margin-top:1rem;">Upcoming Matches</h3>`;
          upcoming.forEach(m => {
            const li = document.createElement('li');
            li.style.opacity = '0.85';
            li.textContent = `Group ${m.group}: ${m.home} vs ${m.away} — ${m.date || 'TBD'}`;
            ul.appendChild(li);
          });
          upcomingDiv.appendChild(ul);
        }

        // Full-league standings at the bottom
        renderFullStandings(groups, matches);
      }

      Promise.all([fetchJSON(GROUPS_URL), fetchJSON(MATCHES_URL)])
        .then(([g, m]) => render(g.groups, (m && m.matches) || []))
        .catch(e => {
          console.error(e);
          root.innerHTML = '<p>Failed to load data.</p>';
        });
    })();
  </script>
</body>
</html>
